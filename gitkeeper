#!/usr/bin/env python3
import argparse
import configparser
import json
import subprocess
from pathlib import Path
import os
import pwd

# third-party deps
try:
    import tabulate
except ImportError:
    print("Missing deps: apt-get install python3-tabulate")


# repo paths
GLOBAL_CONFIG_FILE = Path("/etc/gitkeeper.conf")
# user email
if os.environ.get("SUDO_USER"):
    USER_CONFIG_FILE = pwd.getpwuid(os.environ["SUDO_UID"]).pw_dir + "/.gitkeeper.conf"
else:
    USER_CONFIG_FILE = Path.home() / ".gitkeeper.conf"


class GitRuntimeError(RuntimeError):
    pass


def run_git_command(repo, command, sudo_user=None, raise_on_error=True):
    if sudo_user:
        command = ["sudo", "-u", sudo_user] + command
    command = ["git"] + command
    p = subprocess.run(command, cwd=repo, stdout=subprocess.PIPE)
    if raise_on_error and p.returncode != 0:
        raise GitRuntimeError(f"Error running {command} on {repo}")
    stdout = p.stdout.decode("utf-8")
    if raise_on_error:
        return stdout
    return (p.returncode, stdout)


def main(args):
    current_uid = os.getuid()
    if USER_CONFIG_FILE.exists():
        config = configparser.ConfigParser()
        config.read(USER_CONFIG_FILE)
        user_email = config["user"]["email"]
    else:
        # ask for user email, save it to USER_CONFIG_FILE
        user_email = input("Enter your email: ")
        config = configparser.ConfigParser()
        config["user"] = {"email": user_email}
        with open(USER_CONFIG_FILE, "w") as f:
            config.write(f)
        print(f"You can change your email in {USER_CONFIG_FILE}")

    if not GLOBAL_CONFIG_FILE.exists():
        print(f"Global config file {GLOBAL_CONFIG_FILE} not found")
        exit(1)

    config = json.loads(GLOBAL_CONFIG_FILE.read_text())
    assert type(config) == list

    # repo, status, remote
    table = []

    for repo in config:
        item = [repo, "?", "?"]
        table.append(item)

        try:
            repo = Path(repo)
            # get repo dir owner
            uid = repo.stat().st_uid
            if uid != current_uid:
                sudo_user = pwd.getpwuid(uid).pw_name
            else:
                sudo_user = None
            # print status
            status = run_git_command(repo, ["status", "--porcelain=v1"], sudo_user=sudo_user)
            untracked = 0
            staged = 0
            for line in status.split("\n"):
                if not line:
                    continue
                status, file = line.split(" ", 1)
                if status == "??":
                    untracked += 1
                else:
                    staged += 1
            # print(f"{repo}: {staged} staged, {untracked} untracked files")
            if untracked or staged:
                item[1] = f"‚ùó {staged} staged, {untracked} untracked"
            else:
                item[1] = "‚úÖ clean"

            # get remote info
            remote = run_git_command(repo, ["remote"], sudo_user=sudo_user)
            remote = remote.strip()
            if not remote:
                # print(f"{repo} has no remote")
                item[2] = "N/A"
                continue
            else:
                # fetch
                _ = run_git_command(repo, ["fetch"], sudo_user=sudo_user)
                local_hash = run_git_command(repo, ["rev-parse", "HEAD"], sudo_user=sudo_user)
                remote_hash = run_git_command(repo, ["rev-parse", "@{u}"], sudo_user=sudo_user)
                base_hash = run_git_command(repo, ["merge-base", "HEAD", "@{u}"], sudo_user=sudo_user)
                msg = ""
                if local_hash == remote_hash:
                    msg = "‚úÖ up to date"
                elif local_hash == base_hash:
                    msg = "‚¨áÔ∏è needs pull"
                elif remote_hash == base_hash:
                    msg = "‚¨ÜÔ∏è needs push"
                else:
                    msg = "üîÄ diverged"
                item[2] = msg
        except GitRuntimeError as e:
            print(e)
            continue
    print(tabulate.tabulate(table, headers=["Repo", "Status", "Remote"]))



if __name__ == "__main__":
    parser = argparse.ArgumentParser("Track git repos")
    subparsers = parser.add_subparsers(dest="command")
    parser_status = subparsers.add_parser("status", help="Show status of repo(s)")
    parser_status.add_argument("repo", nargs="*", help="Repo(s) to show status of")
    parser_commit = subparsers.add_parser("commit", help="Commit changes in repo(s) on behalf of current user")
    parser_commit.add_argument("repo", nargs="*", help="Repo(s) to commit changes in")
    parser_git = subparsers.add_parser("vcs", help="Run a git command on repo(s)")
    parser_git.add_argument("repo", nargs="*", help="Repo(s) to run git command on")

    args = parser.parse_args()

    main(args)
