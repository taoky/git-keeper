#!/usr/bin/env python3
import argparse
import configparser
from enum import Enum
import subprocess
from pathlib import Path
import os
import pwd
import signal
from typing import TYPE_CHECKING, Dict, List, Optional, Tuple

# third-party deps
try:
    import tabulate
except ImportError:
    print("Missing deps 'tabulate': apt-get install python3-tabulate")
    exit(1)

try:
    # Python 3.8+
    from typing import TypedDict
except ImportError:
    TypedDict = dict


# user email & name config
if TYPE_CHECKING:

    class InnerUserConfigType(TypedDict):
        path: Path
        user: Optional[str]

else:
    InnerUserConfigType = Dict[str, str]

UserConfigType = Dict[str, InnerUserConfigType]
if os.environ.get("SUDO_USER"):
    USER_CONFIG_FILE = Path(
        pwd.getpwuid(int(os.environ["SUDO_UID"])).pw_dir + "/.gitkeeper.conf"
    )
else:
    USER_CONFIG_FILE = Path.home() / ".gitkeeper.conf"

current_username = os.environ.get("SUDO_USER") or pwd.getpwuid(os.getuid()).pw_name


class GitRuntimeError(RuntimeError):
    returncode: int
    message: str

    def __init__(self, message: str, returncode: int):
        self.message = message
        self.returncode = returncode

    def __str__(self) -> str:
        return f"{self.message} (exit code {self.returncode})"


def _run_git_command(
    repo: Path,
    command: List[str],
    sudo_user: Optional[str] = None,
    raw: bool = False,
    timeout: Optional[float] = None,
) -> Optional[str]:
    if sudo_user:
        command = ["sudo", "-u", sudo_user, "git"] + command
    else:
        command = ["git"] + command
    if not raw:
        p = subprocess.run(command, cwd=repo, stdout=subprocess.PIPE, timeout=timeout)
    else:
        p = subprocess.run(command, cwd=repo, timeout=timeout)
    if p.returncode != 0 and p.returncode != -signal.SIGPIPE:
        raise GitRuntimeError(f"Error running {command} on {repo}", p.returncode)
    if not raw:
        stdout = p.stdout.decode("utf-8")
    else:
        stdout = None
    return stdout


def run_git_command(
    repo: Path,
    command: List[str],
    sudo_user: Optional[str] = None,
    timeout: Optional[float] = None,
) -> str:
    return _run_git_command(repo, command, sudo_user, timeout=timeout)  # type: ignore


def run_git_command_raw(
    repo: Path,
    command: List[str],
    sudo_user: Optional[str] = None,
    timeout: Optional[float] = None,
) -> None:
    _run_git_command(repo, command, sudo_user, raw=True, timeout=timeout)


def get_sudo_user(repo: InnerUserConfigType, current_uid: int) -> Optional[str]:
    if repo.get("user"):
        return repo["user"]
    uid = Path(repo["path"]).stat().st_uid
    if uid != current_uid:
        return pwd.getpwuid(uid).pw_name
    return None


def compare_hashes(repo: Path, sudo_user: Optional[str]) -> Tuple[str, str, str]:
    local_hash = run_git_command(repo, ["rev-parse", "HEAD"], sudo_user=sudo_user)
    remote_hash = run_git_command(repo, ["rev-parse", "@{u}"], sudo_user=sudo_user)
    base_hash = run_git_command(
        repo, ["merge-base", "HEAD", "@{u}"], sudo_user=sudo_user
    )
    return local_hash, remote_hash, base_hash


class LocalRemoteStatus(Enum):
    UP_TO_DATE = 1
    NEEDS_PULL = 2
    NEEDS_PUSH = 3
    DIVERGED = 4


class RemoteType(Enum):
    SSH = 1
    HTTP = 2
    NONE = 3
    UNKNOWN = 4


def fetch_and_compare(repo: Path, sudo_user: Optional[str]) -> LocalRemoteStatus:
    _ = run_git_command(repo, ["fetch"], sudo_user=sudo_user, timeout=30)
    local_hash, remote_hash, base_hash = compare_hashes(repo, sudo_user)
    if local_hash == remote_hash:
        return LocalRemoteStatus.UP_TO_DATE
    elif local_hash == base_hash:
        return LocalRemoteStatus.NEEDS_PULL
    elif remote_hash == base_hash:
        return LocalRemoteStatus.NEEDS_PUSH
    else:
        return LocalRemoteStatus.DIVERGED


def has_remote(repo: Path, sudo_user: Optional[str]) -> RemoteType:
    remote = run_git_command(repo, ["remote"], sudo_user=sudo_user)
    remote = remote.strip()
    if len(remote) == 0:
        return RemoteType.NONE
    url = run_git_command(repo, ["remote", "get-url", remote], sudo_user=sudo_user)
    # ignore http(s) remotes
    if url.startswith("http"):
        return RemoteType.HTTP
    if url.startswith("git@"):
        return RemoteType.SSH
    return RemoteType.UNKNOWN


def get_status(repo: Path, sudo_user: Optional[str]) -> Tuple[int, int]:
    status = run_git_command(repo, ["status", "--porcelain=v1"], sudo_user=sudo_user)
    untracked = 0
    staged = 0
    for line in status.split("\n"):
        if not line:
            continue
        status, file = line.split(" ", 1)
        if status == "??":
            untracked += 1
        else:
            staged += 1
    return (untracked, staged)


def status(config: UserConfigType, repos: List[str], current_uid: int) -> None:
    # repo, status, remote
    table = []
    if not repos:
        repos = list(config.keys())

    for repo_name in repos:
        repo = config[repo_name]
        repo_path = Path(repo["path"])
        item = [repo_path, repo_name, "?", "?"]
        table.append(item)

        try:
            sudo_user = get_sudo_user(repo, current_uid)
            untracked, staged = get_status(repo_path, sudo_user)
            if untracked or staged:
                item[2] = f"❗ {staged} staged, {untracked} untracked"
            else:
                item[2] = "✅ clean"

            # get remote info
            remote = has_remote(repo_path, sudo_user)
            if remote == RemoteType.NONE:
                item[3] = "N/A"
                continue
            elif remote == RemoteType.UNKNOWN:
                item[3] = "Unknown"
                continue
            else:
                status = fetch_and_compare(repo_path, sudo_user)
                msg = ""
                if status == LocalRemoteStatus.UP_TO_DATE:
                    msg = "✅ up to date"
                elif status == LocalRemoteStatus.NEEDS_PULL:
                    msg = "⬇️ needs pull"
                elif status == LocalRemoteStatus.NEEDS_PUSH:
                    msg = "⬆️ needs push"
                else:
                    msg = "🔀 diverged"
                item[3] = msg
        except GitRuntimeError as e:
            print(e)
            continue
    print(tabulate.tabulate(table, headers=["Repo", "Name", "Status", "Remote"]))


def commit(
    repo: InnerUserConfigType,
    current_uid: int,
    user_name: str,
    user_email: str,
    args: List[str],
) -> None:
    try:
        sudo_user = get_sudo_user(repo, current_uid)
        repo_path = Path(repo["path"])
        # commit
        run_git_command(repo_path, ["add", "."], sudo_user=sudo_user)
        run_git_command_raw(
            repo_path,
            [
                "-c",
                f"user.name={user_name}",
                "-c",
                f"user.email={user_email}",
                "commit",
                *args,
            ],
            sudo_user=sudo_user,
        )
    except GitRuntimeError as e:
        print(e)
        exit(1)


def update(config: UserConfigType, current_uid: int) -> None:
    for repo_name in config:
        try:
            repo = config[repo_name]
            sudo_user = get_sudo_user(repo, current_uid)
            repo_path = Path(repo["path"])
            remote = has_remote(repo_path, sudo_user)
            status = fetch_and_compare(repo_path, sudo_user)
            if status == LocalRemoteStatus.UP_TO_DATE:
                continue
            elif status == LocalRemoteStatus.NEEDS_PULL:
                run_git_command(repo_path, ["pull"], sudo_user=sudo_user)
                print(f"Pulled {repo_path}")
            elif status == LocalRemoteStatus.NEEDS_PUSH:
                if remote == RemoteType.HTTP:
                    print(f"Repo {repo_path} has HTTP remote, skipping push")
                    continue
                run_git_command(repo_path, ["push"], sudo_user=sudo_user)
                print(f"Pushed {repo_path}")
            elif status == LocalRemoteStatus.DIVERGED:
                print(f"Repo {repo_path} has diverged (requires manual intervention)")
        except GitRuntimeError as e:
            print(e)
            continue


def vcs(repo: InnerUserConfigType, current_uid: int, args: List[str]) -> None:
    try:
        sudo_user = get_sudo_user(repo, current_uid)
        repo_path = Path(repo["path"])
        run_git_command_raw(repo_path, args, sudo_user=sudo_user)
    except GitRuntimeError as e:
        print(e)
        exit(1)


def diff(repo: InnerUserConfigType, current_uid: int) -> None:
    try:
        sudo_user = get_sudo_user(repo, current_uid)
        repo_path = Path(repo["path"])
        # 1. Show git status output
        run_git_command_raw(repo_path, ["status"], sudo_user=sudo_user)
        input("Press enter to show `git diff`")
        # 2. Show git diff output
        run_git_command_raw(repo_path, ["diff"], sudo_user=sudo_user)
    except GitRuntimeError as e:
        print(e)
        exit(1)
    except KeyboardInterrupt:
        pass


def main(args: argparse.Namespace) -> None:
    current_uid = os.getuid()
    if USER_CONFIG_FILE.exists():
        parser = configparser.ConfigParser()
        parser.read(USER_CONFIG_FILE)
        user_email = parser["user"]["email"]
    else:
        # ask for user email, save it to USER_CONFIG_FILE
        user_email = input("Enter your email: ")
        parser = configparser.ConfigParser()
        parser["user"] = {"email": user_email}
        with open(USER_CONFIG_FILE, "w") as f:
            parser.write(f)
        print(f"You can change your email in {USER_CONFIG_FILE}")
    user_name = parser["user"].get("name", current_username)

    if not args.config.exists():
        print(f"Global config file {args.config} not found")
        exit(1)

    parser = configparser.ConfigParser()
    parser.read(args.config)
    _config = {k: dict(parser.items(k)) for k in parser.sections()}
    # check if config is valid
    config: UserConfigType = {}
    for repo_name in _config:
        config[repo_name] = {}  # type: ignore
        config[repo_name]["path"] = Path(_config[repo_name]["path"])
        if _config[repo_name].get("user"):
            config[repo_name]["user"] = _config[repo_name]["user"]

    repos: List[str]
    if args.command == "status":
        repos = args.repos
        status(config, repos, current_uid)
    elif args.command == "commit":
        repo_name = args.repo
        repo = config[repo_name]
        commit(repo, current_uid, user_name, user_email, args.args)
    elif args.command == "update":
        repos = args.repos
        if repos:
            new_config: UserConfigType = {}
            for repo_name in repos:
                new_config[repo_name] = config[repo_name]
            config = new_config
        update(config, current_uid)
    elif args.command == "vcs":
        repo_name = args.repo
        repo = config[repo_name]
        vcs(repo, current_uid, args.args)
    elif args.command == "ls":
        print("\n".join(config.keys()))
    elif args.command == "diff":
        repo_name = args.repo
        repo = config[repo_name]
        diff(repo, current_uid)



if __name__ == "__main__":
    parser = argparse.ArgumentParser("Track git repos")
    parser.add_argument(
        "--config",
        "-c",
        help="Path to config file",
        default="/etc/gitkeeper.conf",
        type=Path,
    )
    subparsers = parser.add_subparsers(dest="command")

    parser_status = subparsers.add_parser("status", help="Show status of repo(s)")
    parser_status.add_argument("repos", nargs="*", help="Repo(s) to show status of")

    parser_commit = subparsers.add_parser(
        "commit", help="Add all and commit changes in repo(s) on behalf of current user"
    )
    parser_commit.add_argument("repo", help="The repo to commit changes in")
    parser_commit.add_argument(
        "args", nargs=argparse.REMAINDER, help="Arguments appended to git commit"
    )

    parser_update = subparsers.add_parser(
        "update", help="Push/pull repo(s) with remote"
    )
    parser_update.add_argument("repos", nargs="*", help="Repo(s) to push/pull")

    parser_vcs = subparsers.add_parser("vcs", help="Run a git command on repo(s)")
    parser_vcs.add_argument("repo", help="The repo to run git command on")
    parser_vcs.add_argument("args", nargs=argparse.REMAINDER, help="Arguments to git")

    parser_ls = subparsers.add_parser("ls", help="Just list all repos")
    parser_diff = subparsers.add_parser("diff", help="Show changes in given repo")
    parser_diff.add_argument("repo", help="The repo to show diff of")

    args = parser.parse_args()
    if args.command is None:
        args.command = "status"
        args.repos = []

    main(args)
