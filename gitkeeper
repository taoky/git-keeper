#!/usr/bin/env python3
import argparse
import configparser
from enum import Enum
import json
import subprocess
from pathlib import Path
import os
import pwd
from typing import Optional, Tuple

# third-party deps
try:
    import tabulate
except ImportError:
    print("Missing deps: apt-get install python3-tabulate")


# repo paths
GLOBAL_CONFIG_FILE = Path("/etc/gitkeeper.conf")
# user email
if os.environ.get("SUDO_USER"):
    USER_CONFIG_FILE = pwd.getpwuid(os.environ["SUDO_UID"]).pw_dir + "/.gitkeeper.conf"
else:
    USER_CONFIG_FILE = Path.home() / ".gitkeeper.conf"

current_username = os.environ.get("SUDO_USER") or pwd.getpwuid(os.getuid()).pw_name


class GitRuntimeError(RuntimeError):
    returncode: int
    message: str

    def __init__(self, message: str, returncode: int):
        self.message = message
        self.returncode = returncode
    
    def __str__(self):
        return f"{self.message} (exit code {self.returncode})"


def run_git_command(
    repo,
    command: list,
    sudo_user: str = None,
    raise_on_error: bool = True,
    raw: bool = False,
    timeout: Optional[float] = None,
):
    if sudo_user:
        command = ["sudo", "-u", sudo_user, "git"] + command
    else:
        command = ["git"] + command
    if not raw:
        p = subprocess.run(command, cwd=repo, stdout=subprocess.PIPE, timeout=timeout)
    else:
        p = subprocess.run(command, cwd=repo, timeout=timeout)
    if raise_on_error and p.returncode != 0:
        raise GitRuntimeError(f"Error running {command} on {repo}", p.returncode)
    if not raw:
        stdout = p.stdout.decode("utf-8")
    else:
        stdout = None
    if raise_on_error:
        return stdout
    return (p.returncode, stdout)


def get_sudo_user(repo: Path, current_uid: int) -> Optional[str]:
    uid = repo.stat().st_uid
    if uid != current_uid:
        return pwd.getpwuid(uid).pw_name
    return None


def compare_hashes(repo: Path, sudo_user: str):
    local_hash = run_git_command(repo, ["rev-parse", "HEAD"], sudo_user=sudo_user)
    remote_hash = run_git_command(repo, ["rev-parse", "@{u}"], sudo_user=sudo_user)
    base_hash = run_git_command(
        repo, ["merge-base", "HEAD", "@{u}"], sudo_user=sudo_user
    )
    return local_hash, remote_hash, base_hash


class LocalRemoteStatus(Enum):
    UP_TO_DATE = 1
    NEEDS_PULL = 2
    NEEDS_PUSH = 3
    DIVERGED = 4


class RemoteType(Enum):
    SSH = 1
    HTTP = 2
    NONE = 3
    UNKNOWN = 4


def fetch_and_compare(repo: Path, sudo_user: str) -> LocalRemoteStatus:
    _ = run_git_command(repo, ["fetch"], sudo_user=sudo_user, timeout=30)
    local_hash, remote_hash, base_hash = compare_hashes(repo, sudo_user)
    if local_hash == remote_hash:
        return LocalRemoteStatus.UP_TO_DATE
    elif local_hash == base_hash:
        return LocalRemoteStatus.NEEDS_PULL
    elif remote_hash == base_hash:
        return LocalRemoteStatus.NEEDS_PUSH
    else:
        return LocalRemoteStatus.DIVERGED


def has_remote(repo: Path, sudo_user: str) -> RemoteType:
    remote = run_git_command(repo, ["remote"], sudo_user=sudo_user)
    remote = remote.strip()
    if len(remote) == 0:
        return RemoteType.NONE
    url = run_git_command(repo, ["remote", "get-url", remote], sudo_user=sudo_user)
    # ignore http(s) remotes
    if url.startswith("http"):
        return RemoteType.HTTP
    if url.startswith("git@"):
        return RemoteType.SSH
    return RemoteType.UNKNOWN


def get_status(repo: Path, sudo_user: str) -> Tuple[int, int]:
    status = run_git_command(repo, ["status", "--porcelain=v1"], sudo_user=sudo_user)
    untracked = 0
    staged = 0
    for line in status.split("\n"):
        if not line:
            continue
        status, file = line.split(" ", 1)
        if status == "??":
            untracked += 1
        else:
            staged += 1
    return (untracked, staged)


def status(config: dict, current_uid: int) -> None:
    # repo, status, remote
    table = []

    for repo in config:
        name = repo
        repo = config[repo]
        item = [repo, name, "?", "?"]
        table.append(item)

        try:
            repo = Path(repo)
            sudo_user = get_sudo_user(repo, current_uid)
            untracked, staged = get_status(repo, sudo_user)
            if untracked or staged:
                item[2] = f"‚ùó {staged} staged, {untracked} untracked"
            else:
                item[2] = "‚úÖ clean"

            # get remote info
            remote = has_remote(repo, sudo_user)
            if remote == RemoteType.NONE:
                item[3] = "N/A"
                continue
            elif remote == RemoteType.UNKNOWN:
                item[3] = "Unknown"
                continue
            else:
                status = fetch_and_compare(repo, sudo_user)
                msg = ""
                if status == LocalRemoteStatus.UP_TO_DATE:
                    msg = "‚úÖ up to date"
                elif status == LocalRemoteStatus.NEEDS_PULL:
                    msg = "‚¨áÔ∏è needs pull"
                elif status == LocalRemoteStatus.NEEDS_PUSH:
                    msg = "‚¨ÜÔ∏è needs push"
                else:
                    msg = "üîÄ diverged"
                item[3] = msg
        except GitRuntimeError as e:
            print(e)
            continue
    print(tabulate.tabulate(table, headers=["Repo", "Name", "Status", "Remote"]))


def commit(repo: str, current_uid: int, user_name: str, user_email: str, args: list):
    try:
        repo = Path(repo)
        sudo_user = get_sudo_user(repo, current_uid)
        # commit
        run_git_command(repo, ["add", "."], sudo_user=sudo_user)
        run_git_command(
            repo,
            [
                "-c",
                f"user.name={user_name}",
                "-c",
                f"user.email={user_email}",
                "commit",
                *args,
            ],
            sudo_user=sudo_user,
            raw=True,
        )
    except GitRuntimeError as e:
        print(e)
        exit(1)


def update(config: dict, current_uid: int):
    for repo_name in config:
        try:
            repo = Path(config[repo_name])
            sudo_user = get_sudo_user(repo, current_uid)
            remote = has_remote(repo, sudo_user)
            status = fetch_and_compare(repo, sudo_user)
            if status == LocalRemoteStatus.UP_TO_DATE:
                continue
            elif status == LocalRemoteStatus.NEEDS_PULL:
                run_git_command(repo, ["pull"], sudo_user=sudo_user)
                print(f"Pulled {repo}")
            elif status == LocalRemoteStatus.NEEDS_PUSH:
                if remote == RemoteType.HTTP:
                    print(f"Repo {repo} has HTTP remote, skipping push")
                    continue
                run_git_command(repo, ["push"], sudo_user=sudo_user)
                print(f"Pushed {repo}")
            elif status == LocalRemoteStatus.DIVERGED:
                print(f"Repo {repo} has diverged (requires manual intervention)")
        except GitRuntimeError as e:
            print(e)
            continue


def vcs(repo: str, current_uid: int, args: list):
    try:
        repo = Path(repo)
        sudo_user = get_sudo_user(repo, current_uid)
        run_git_command(repo, args, sudo_user=sudo_user, raw=True)
    except GitRuntimeError as e:
        print(e)
        if e.returncode == -13:
            # SIGPIPE, ignore
            print("SIGPIPE, ignoring...")
            exit(0)
        exit(1)


def main(args):
    current_uid = os.getuid()
    if USER_CONFIG_FILE.exists():
        config = configparser.ConfigParser()
        config.read(USER_CONFIG_FILE)
        user_email = config["user"]["email"]
    else:
        # ask for user email, save it to USER_CONFIG_FILE
        user_email = input("Enter your email: ")
        config = configparser.ConfigParser()
        config["user"] = {"email": user_email}
        with open(USER_CONFIG_FILE, "w") as f:
            config.write(f)
        print(f"You can change your email in {USER_CONFIG_FILE}")
    user_name = config["user"].get("name", current_username)

    if not GLOBAL_CONFIG_FILE.exists():
        print(f"Global config file {GLOBAL_CONFIG_FILE} not found")
        exit(1)

    config = json.loads(GLOBAL_CONFIG_FILE.read_text())
    assert type(config) == dict

    if args.command == "status":
        status(config, current_uid)
    elif args.command == "commit":
        repo = args.repo
        repo_path = config[repo]
        commit(repo_path, current_uid, user_name, user_email, args.args)
    elif args.command == "update":
        repo = args.repo
        if repo:
            new_config = {}
            for r in repo:
                new_config[r] = config[r]
            config = new_config
        update(config, current_uid)
    elif args.command == "vcs":
        repo = args.repo
        repo_path = config[repo]
        vcs(repo_path, current_uid, args.args)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Track git repos")
    parser.add_argument("--config", "-c", help="Path to config file", default=None)
    subparsers = parser.add_subparsers(dest="command")
    parser_status = subparsers.add_parser("status", help="Show status of repo(s)")
    parser_status.add_argument("repo", nargs="*", help="Repo(s) to show status of")
    parser_commit = subparsers.add_parser(
        "commit", help="Add all and commit changes in repo(s) on behalf of current user"
    )
    parser_commit.add_argument("repo", help="Repo(s) to commit changes in")
    parser_commit.add_argument(
        "args", nargs=argparse.REMAINDER, help="Arguments appended to git commit"
    )
    parser_update = subparsers.add_parser(
        "update", help="Push/pull repo(s) with remote"
    )
    parser_update.add_argument("repo", nargs="*", help="Repo(s) to push/pull")
    parser_git = subparsers.add_parser("vcs", help="Run a git command on repo(s)")
    parser_git.add_argument("repo", help="Repo(s) to run git command on")
    parser_git.add_argument("args", nargs=argparse.REMAINDER, help="Arguments to git")

    args = parser.parse_args()
    if args.command is None:
        args.command = "status"
    if args.config:
        GLOBAL_CONFIG_FILE = Path(args.config)

    main(args)
